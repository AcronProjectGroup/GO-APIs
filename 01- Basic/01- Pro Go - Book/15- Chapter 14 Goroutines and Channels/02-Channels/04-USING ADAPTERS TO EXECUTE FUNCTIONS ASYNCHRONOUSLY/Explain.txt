It isn’t always possible to rewrite existing functions or methods to use channels, but it is a simple matter
to execute synchronous functions asynchronously in a wrapper, like this:
...
calcTax := func(price float64) float64 {
    return price + (price * 0.2)
}
wrapper := func (price float64, c chan float64)  {
    c <- calcTax(price)
}
resultChannel := make(chan float64)
go wrapper(275, resultChannel)
result := <- resultChannel
fmt.Println("Result:", result)
...
The wrapper function receives a channel, which it uses to send the value received from executing the
calcTax function synchronously. This can be expressed more concisely by defining a function without
assigning it to a variable, like this:
...
go func (price float64, c chan float64) {
    c <- calcTax(price)
}(275, resultChannel)
...
The syntax is a little awkward because the arguments used to invoke the function are expressed
immediately following the function definition. But the result is the same, which is that a synchronous
function can be executed by a goroutine with the result being sent through a channel.