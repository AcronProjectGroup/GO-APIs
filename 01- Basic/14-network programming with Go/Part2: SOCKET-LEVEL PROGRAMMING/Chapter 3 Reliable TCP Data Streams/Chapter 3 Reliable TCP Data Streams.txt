

My Unknown Vovalbulary:
|   1- Receipt = اعلام وصول
|   2- determines = تعیین می کند
|   3- In this snippet of communication = در این برش از ارتباط 
|

Chapter 3: RELIABLE TCP DATA STREAMS
|
|   TCP allows you to reliably stream data between nodes on a network.
|
|   We’ll start by covering:
|       the TCP handshake process 
|       its sequence num-bers 
|       acknowledgments 
|       retransmissions
|       and other features.
|   
|   Next, implement the steps of a TCP session in Go:
|       from dialing
|       listening
|       accepting to the session termination 
|   
|   Next discuss:
|       time-outs 
|       temporary errors
|       how to detect them?
|       how to use them to keep our users happy?
|   
|   Finally, cover:
|       the early detection of unreliable network connections
|   
|   Go’s standard library allows you to write robust TCP-based networking applications.
|   
|   if you aren’t mindful of managing incoming data or properly closing connections, 
|   you’ll experience insidious bugs in your programs.

congestion =  تراکم، شلوغی

What Makes TCP Reliable?
|   TCP is reliable because it overcomes the effects of packet loss or receiv-ing packets out of order.
|      
|   Network congestion happens when nodes attempt to send more data over 
|   a network connection than the connection can handle, causing the nodes to discard the excess packets.
|   
|   TCP adapts its data transfer rate to make sure it transmits data as fast as possible while keeping 
|   dropped packets to a minimum, even if the network conditions change

Working with TCP Seccions:
|   Much like the occasional head nod that people use to indicate they’re listening 
|   to someone speaking, streaming allows you to receive feedback from the recipient
|   while the transfer is taking place so that you can correct any errors in real time.
|   In fact, you can think of a TCP session as you would a conversation between two nodes. 
|   It starts with a greeting, progresses into the conversation, and concludes with a farewell.

Establishing a Session with the TCP Handshake:
|   A TCP connection uses a three-way handshake to introduce the client to the server and the server to the client.
|   Figure 3-1
|   
|   Before it can establish a TCP session, the server must listen for incom-ing connections.
|   
|   TCP itself doesn’t have a concept of a client and server, 
|   but an established session between two nodes, 
|   whereby one node reaches out to another node to establish the session.
|   
|   1- As the first step of the handshake, 
|      the client sends a packet with the synchronize (SYN) flag 
|      to the server. This SYN packet informs the server of the client’s capabilities 
|      and preferred window settings for the rest of the conversation. 
|
|   2- Next, the server responds with its own packet, 
|      with both the acknowledgment (ACK) and SYN flags set.
|      The ACK flag tells the client that the server 
|      acknowledges receipt of the client’s SYN packet.
|
|   3- Finally, the client replies with an ACK packet 
|      to acknowledge the server’s SYN packet, 
|      completing the three-way handshake.
|   
|   When you initiate a connection in your code, 
|   Go will return either a connection object or an error. 
|   If you receive a connection object, 
|   the TCP handshake succeeded. 
|   You do not need to manage the handshake yourself.
|   Acknowledging Receipt of Packets by Using Their Sequence
|   NumbersEach TCP packet contains a sequence number, 
|   which the receiver uses to acknowledge receipt of each packet 
|   and properly order the packets for presentation to your 
|   Go application (Figure 3-2). 


Acknowledging Receipt of Packets by Using Their Sequence Numbers: تأیید دریافت بسته ها با استفاده از شماره های ترتیبی آنها
|   Each TCP packet contains a sequence number, 
|   which the receiver uses to acknowledge receipt 
|   of each packet and properly order the packets 
|   for pre-sentation to your Go application (Figure 3-2).
|
|   The client’s operating system determines the initial sequence number
|   and sends it to the server in the client’s SYN packet during the handshake. 
|   
|   The server acknowledges receipt of the packet by including 
|   this sequence number in its ACK packet to the client. 
|   
|   Next, he server shares its generated sequence number Y 
|   in its SYN packet to the client. The client replies with
|   its ACK to the server.
|   
|   While writing and debugging network programs, 
|   it’s often necessary to view the traffic your code sends and receives. 
|   To capture and inspect TCP packets,

Receive Buffers and Window Sizes: بافرها و اندازه‌های پنجره را دریافت کنید
|   A "receive buffer" is a block of memory reserved for incoming data
|   on a network connection.
|   
|   ACK packets include a particularly important piece of information: 
|   the "window size", which is the number of bytes the sender can 
|   transmit to the receiver without requiring an acknowledgment. 


Gracefully Terminating TCP Sessions: پایان دادن به جلسات
|   Either side of the connection may initi-ate the termination sequence 
|   by sending a finish (FIN) packet.Figure 3-4
|   
|   1- the client initiates the termination by sending a FIN packet to the server.
|   2- The client’s connection state changes from ESTABLISHED to FIN_WAIT_1
|   3- The server acknowledges the client’s FIN and changes its connection state from ESTABLISHED to CLOSE_WAIT.
|   4- The server sends its own FIN packet, changing its state to LAST_ACK, indicating it’s waiting for a final acknowl-edgment from the client. 
|   5- The client acknowledges the server’s FIN and enters a TIME_WAIT state, whose purpose is to allow the client’s final ACK packet to reach the server. 
|      The client waits for twice the maximum segment life-time (the segment lifetime arbitrarily defaults to two minutes, per RFC 793, but your operating system may allow you to tweak this value), then changes its connection state to CLOSED without any further input required from the server.
|   
|   The maximum segment lifetime is the duration a TCP segment can remain in transit before the sender considers it abandoned. 

Handling Less Graceful Terminations: مدیریت خاتمه های کمتر دلپذیر
|   Not all connections politely terminate. In some cases, the application that opened a TCP connection may crash or abruptly stop running for some reason. When this happens, the TCP connection is immediately closed. Any packets sent from the other side of the former connection will prompt the closed side of the connection to return a reset (RST) packet.


Establishing a TCP Connection by Using Go’s Standard Library:
|   Your software should be attentive to incoming data and always strive to gracefully shut down the connection. نرم افزار شما باید به داده های دریافتی توجه داشته باشد و همیشه سعی کند اتصال را با ظرافت قطع کند.


Binding, Listening for, and Accepting Connections: اتصال، گوش دادن و پذیرش اتصالات
|   To create a TCP server capable of listening for incoming connections (called a listener), use the net.Listen function. This function will return an object that implements the net.Listener interface. Listing 3-1 shows the cre-ation of a listener.
|   File is here 05-Simple-Server.go
|   
|   
|   
|   
|   
|   
|   
|   
|   
|   
|   




































































